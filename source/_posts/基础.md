---
title: 基础
date: 2021-07-25 11:24:17
tags:
categories:
---

Css

- 布局
- 定位
- 移动端

ES

- 原型
- 作用域 闭包
- 异步 单线程

Web

- DOM BOM
- ajax 跨域
- 事件 存储

开发环境

- 版本管理
- 调试抓包
- 打包构建

运行环境

- 页面渲染
- 性能优化
- web安全

网络

- headers
- Restful API
- 缓存策略





# HTML CSS

- html语义化：html结构化，代码易读，利于SEO
- 块级元素 内联元素
  - 块级：独占一行
    - display: block/table; div h1 h2 table ul ol p
  - 内联：不会独占一行
    - display:inline / inline-block; span img input button
- 盒模型的宽度
  - offsetWidth = 内容宽度 + 内边距 + 边框
  - box-sizing:border-box; 不会被padding撑开
- margin纵向重叠
  - 在标准文档流中，竖直方向（是**竖直方向**，**水平方向**的**不会出现**塌陷现象）的margin会出现叠加现象，即较大的margin会覆盖掉较小的margin，竖直方向的两个盒子中间只有一个较大的margin]
  - **垂直之间塌陷的原则是以两盒子最大的外边距为准**
  - 相邻元素的margin-top和margin-bottom会发生重叠
  - 空白内容的p标签也会重叠
- margin负值
  - margin-top和margin-left设置负值的话，元素会分别向上或向左移动；
  - margin-right设置负值，右侧元素左移，自身不受影响；
  - margin-bottom设置负值，下方元素上移，自身不受影响；
- BFC
  - 块级格式化上下文 block format context
  - 一块独立渲染区域，内部元素的渲染不影响边界以外的元素
  - [BFC](https://zhuanlan.zhihu.com/p/25321647)
  - [bfc](https://blog.csdn.net/sinat_36422236/article/details/88763187)
- float clearfix
- flex
  - Flex-direction
  - Justify-content
  - Align-items
  - flex-wrap
  - align-self
  - 
- absolute relative
- 居中对齐
- line-height
- rem em px
- 响应式实现
- CSS3 动画
- 

# JS

- typeof

  - 判断所有值类型
  - 判断函数
  - 判断是否时引用类型

- === ==

- 值类型 引用类型

  - Undefined number string boolean symbol
  - Object array null function

- 深拷贝

  - ```
    function deepCopy(obj1) {
        var obj2 = Array.isArray(obj1) ? [] : {};
        if (obj1 && typeof obj1 === "object") {
            for (var i in obj1) {
                var prop = obj1[i]; // 避免相互引用造成死循环，如obj1.a=obj
                if (prop == obj1) {
                    continue;
                }
                if (obj1.hasOwnProperty(i)) {
                    // 如果子属性为引用数据类型，递归复制
                    if (prop && typeof prop === "object") {
                        obj2[i] = (prop.constructor === Array) ? [] : {};
                        arguments.callee(prop, obj2[i]); // 递归调用
                    } else {
                        // 如果是基本数据类型，只是简单的复制
                        obj2[i] = prop;
                    }
                }
            }
        }
        return obj2;
    }
    ```

- 原型和原型链
  - 创建一个函数的时候，系统就会自动分配一个 `prototype`属性，可以用来存储可以让所有实例共享的属性和方法
  - 每一个构造函数都拥有一个 `prototype` 属性，这个属性指向一个对象，也就是原型对象
  - 原型对象默认拥有一个 `constructor` 属性，指向指向它的那个构造函数
  - 每个对象都拥有一个隐藏的属性 `__proto__`，指向它的原型对象
- 作用域和闭包
  - 全局作用域
  - 函数作用域
  - 块级作用域
  - 闭包：函数作为返回值或者参数传递，自由变量查找，从函数被定义的地方开始
    - 隐藏数据
- this
  - 在函数执行时定义
- 异步和单线程

## event loop

计算机系统的一种运行机制，js采用这种机制，来解决单线程的一些问题

- 事件循环
- js单线程
- 异步基于回调实现
- event loop就是异步回调的实现原理

js执行顺序

- 逐行执行
- 报错则停止
- 先执行同步代码，再执行异步代码

（1）所有同步任务都在主线程上执行，形成一个[执行栈](https://www.ruanyifeng.com/blog/2013/11/stack.html)（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

## 宏任务 微任务

- 宏任务

  - (macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

  - 浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染

  - 包括

    - ```text
      script(整体代码)
      setTimeout
      setInterval
      I/O
      UI交互事件
      postMessage
      MessageChannel
      setImmediate(Node.js 环境)
      ```

- 微任务

  - microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前

  - 包括

    - ```text
      Promise.then
      Object.observe
      MutaionObserver
      process.nextTick(Node.js 环境)
      ```

遇到同步任务时，在主线程立刻执行该任务。

此时主线程上有一个执行栈（execution context stack），所有同步代码会按顺序执行。

遇到异步任务时，异步任务会进入到Event Table，当异步任务有结果后，将相对应的回调函数进行注册，放入事件队列（Event Queue）；（异步的宏任务有结果后，会放入宏任务事件队列；异步的微任务有结果后，会放入微任务事件队列；）

（1）主线程从上到下依次执行所有同步任务
（2）主线程读取微任务事件队列，若存在微任务，则依次执行所有微任务
（3）主线程读取宏任务事件队列，若存在宏任务，则依次执行所有宏任务
（4）依次重复第2步和第3步，直到清空微任务事件队列和宏任务事件队列

## promise

- 三种状态，状态不可逆
  - pending 不会触发then和catch
  - resolve 触发then
  - reject 触发catch
- then 正常返回resolved，里面报错的话则返回rejected
- catch 正常返回resolved 里面有报错则返回rejected

# BOM

- nvaigator 浏览器信息
  - userAgent
- screen
  - 屏幕信息
- location
  - url信息
- History
  - 路由

# XmlHttpRequest

```js
const xhr = new XmlHttpRequets()
xhr.open("GET","/api",false)
xhr.onreadystatechange = function () {
  if(xhr.readyState === 4) {
    if(xhr.status === 200) {
      // success
    }
  }
}
xhr.send(null)
```

# 缓存

- cookie 本身用于浏览器和服务端通信，被借用作为本地存储，会随着请求一同发送到服务器
- localStorage 永久本地存储
- sessionStorage 会话期间有效，关闭浏览器则删除
- [前端缓存](https://jiezai.online/2021/05/13/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/#%E5%88%86%E7%B1%BB)

# http

- 状态码
  - 1xx 服务器收到请求
  - 2xx 请求成功
  - 3xx 重定向 浏览器自动处理
  - 4xx 客户端错误
  - 5xx 服务端错误
- headers
- 缓存

# 运行环境

## 页面加载过程

从输入url到渲染出页面的整个过程

- 输入url
- dns解析：域名解析为IP地址
- TCP连接
- 发起http请求
- 服务器处理请求并返回
- 渲染页面
  - 解析HTML，构建DOM树
  - 解析CSS，生成CSS规则树
  - 合并DOM树和CSS规则树，生成render树
  - 布局render树
  - 绘制render数、树，即绘制页面像素信息
  - GPU将各层合成，结果呈现在浏览器窗口中。
- 断开链接



## 性能优化

减少资源体积 压缩代码

减少访问次数 合并代码 缓存

CDN

css head js放最下面

## 安全

xss

xsrf

# 问题

- var let const
  - var 变量提升 
  - let const 块级作用域
- typeof
  - 值类型
  - object
  - function
- 类型转换
  - 强制：parseInt parseFloat toString
  - 隐式： if 逻辑运算 == +
- 深度比较 模拟 lodash isEqual
- split join 区别
- slice splice
- Call apply 
  - 参数分开
- 事件代理 委托
- 闭包

