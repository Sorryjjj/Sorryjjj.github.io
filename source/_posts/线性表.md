---
title: 线性表
date: 2021-04-04 19:35:16
tags: [线性表,顺序表,链表]
categories: 数据结构
---

# 线性表

## 定义

线性表（linear list）是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表

## 特点

- 线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。 
- 除第一个元素外，每个元素有且仅有一个直接前驱。
-  除最后一个元素外，每个元素有且仅有一个直接后继。

## 基本操作

- 初始化
- 销毁
- 插入
- 删除
- 按值查找
- 按位查找

## 存储结构

- 顺序存储：顺序表
- 链式存储：链表

# 顺序表

## 定义

用顺序存储的方式实现线性表：把逻辑上相邻的元素存储在物理位置也相邻的存储单元中

## 实现

### 静态分配

```c++
#define MaxSize 10;
typedef struct {
  int data[MaxSize];
  int length;
} SeqList;

//初始化
void InitList(SqlList &L) {
  for(int i = 0; i< MaxSize; i++) {
    L.data[i] = 0;
  }
  L.length = 0;
}
...
```

### 动态分配

```c++
#define InitSize 10;
typedef struct {
  int *data;
  int MaxSize;
  int length;
} SeqList;

void InitList(SeqList &L) {
  L.data = (int *) malloc(InitSize * sizeof(int));
  L.length = 0;
  L.MaxSize = InitSize;
}

void IncreaseSize(SeqList &L, int len) {
  int *p = L.data;
  L.data = (int *) malloc((L.MaxSize + len) * sizeof(int));
  for(int i = 0; i< L.length; i++) {
    L.data[i] = p[i];
  }
  L.MaxSize = L.MaxSize + len;
  free(p);
}
```

## 特点

- 随机访问：可以在O(1)时间内找到第i个元素
- 存储密度高，每个节点只存储数据元素
- 拓展容量不方便
- 插入、删除数据元素不方便

## 插入

```c++
bool ListInsert(SeqList &L, int i, int e) {  
  if(i < 1 || i > L.length+1) {
    return false;
  }
  if(L.length > L.MaxSize) {
    return false;
  }
  for(int j = L.length; j >= i; j--) {    
    L.data[j] = L.data[j-1];  
  }  
  L.data[i-1] = e;  
  L.length++;
  return true;
}
```

## 删除

```c++
bool ListDelete(SeqList &L, int i, int &e) {  
  if(i < 1 || i > L.length) {
    return false;
  }
  e = L.data[i-1];
  for(int j = i; j < L.length; j++) {    
    L.data[j-1] = L.data[j];  
  }
  L.length--;
  return true;
}
```

## 查找

# 链表

- 单链表
- 双链表
- 循环链表
- 静态链表

## 单链表

```c++
typedef struct LNode{
  ElemType data;
  struct LNode *next;
} LNode, *LinkList;
```

```c++
//不带头结点
bool InitList(LinkList &L) {
  L = NULL;
  return true;
}
//带头结点
bool InitList1(LinkList &L) {
  L = (LNode *)malloc(sizeof(LNode));
  if(L == NULL) {
    return false;
  }
  L->next = NULL;
  return true;
}
```

### 插入

```c++
//按位插入
bool ListInsert(LinkList &L, int i, ElemType e) {
  if(i<1) {
    return false;
  }
  LNode *p;
  int j = 0;
  p = L;
  while(p != NULL && j < i-1) {
    p = p->next;
    j++;
  }
  if(p == NULL) {
    return false;
  }
  LNode *s = (LNode *)malloc(sizeof(LNode));
  s->data = e;
  s->next = p->next;
  p->next = s;
  return true;
}

//指定结点的前插操作：在p结点前插入s结点
bool InsertPriorNode(LNode *p, LNode *s) {
  if(p == NULL || s == NULL) {
    return false;
  }
  s->next = p->next;
  p->next = s;
  ElemType temp = p->data;//s连接到p之后，交换数据域部分
  p->data = s->data;
  s->data = temp;
  return true;
}
```

### 删除

```c++
//删除指定结点，仅当p不是最后一个结点
bool DeleteNode(LNode *p) {
  if(p == NULL) {
    return false;
  }
  LNode *q = p->next;
  p->data = p->next->data;
  p->next = q->next;
  free(q);
  return true;
}
```

### 尾插法

```c++
LinkList List_TailInsert(LinkList &L) {
  int x;
  L = (LinkList)malloc(sizeof(LinkList));
  LNode *s,*r = L;
  scanf("%d",&x);
  while(x != 9999) {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = x;
    r->next = s;
    r = r->next;
    scanf("%d",&x);
  }
  r->next = NULL;
  return L;
}
```

### 头插法

```c++
LinkList List_HeadInsert(LinkList &L) {
  int x;
  L = (LinkList)malloc(sizeof(LinkList));
  L->next = null;
  LNode *s;
  scanf("%d",&x);
  while(x != 9999) {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = x;
    s->next = L->next;
    L->next = s;
    scanf("%d",&x);
  }
  r->next = NULL;
  return L;
}
```

常用于链表的逆置

## 双链表

```c++
typedef struct DNode{
  ElemType data;
  struct LNode *prior, *next;
} DNode, *DLinkList;

//在p结点之后插入s结点
bool InsertNextDNode(DNode *p,DNode *s){
  if(p == NULL || s == NULL) {
    return false;
  }
  s->next = p->next;
  if(p->next != NULL) {
    p->next->prior = s;
  }
  p->next = s;
  s->prior = p;
}

//删除p的后继结点
bool DeleteNextDNode(DNode *p) {
  if(p == NULL) return false;
  DNode *q = p->next;
  p->next = q->next;
  if(q->next != NULL) {
    q->next->prior = p;
  }
  free(q);
  return true;
}
```

## 循环链表

## 静态链表