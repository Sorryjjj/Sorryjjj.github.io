---
title: Java基础3
date: 2021-01-19 21:11:59
tags: Java
categories: Java
---

# 匿名对象

指没有名字的对象，即只创建对象，但是不用变量来接收

- 匿名对象具有对象的所有功能
- 匿名对象只能调用一次
- 匿名对象只在堆内存中开辟空间，而不存在栈内存的引用

# 方法

- 重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者类型不同即可
- 可变个数的形参：(String ... args)
- 方法参数的值传递机制：如果变量是基本数据类型，则传递的是变量的数据值；如果是引用数据类型，则传递的是变量的地址值
- 递归

# 封装

隐藏对象内部的复杂性，只对外公开简单的接口

- 高内聚：类的内部数据操作细节自己完成，不允许外部干涉
- 低耦合：仅对外暴露少量的方法用于使用

权限修饰符：

- private：类内部
- 缺省：同一个包
- protected：不同包的子类
- public：同一个工程

# 构造器

创建对象，初始化对象

- 如果没有显式定义构造器，默认提供无参构造器
- 定义构造器的格式：权限修饰符  类名 (形参列表) {}
- 一个类中的多个构造器，彼此构成重载
- 一旦显式定义构造器后，系统不再提供默认的无参构造器

# JavaBean

是一种Java语言写成的可重用组件，指符合如下标准的Java类

- 类是公共的
- 有一个无参构造器
- 有属性，且具有对应的get、set方法

# UML类图

# this

this调用构造器

- 在类的构造器中，可以显式的使用“this(形参列表)”调用当前类的其他构造器
- 必须声明在当前构造器的首行
- 构造器内部，最多只能声明一个“this(形参列表)”用来调用其他构造器

# package、import

## package

- 为了更好的管理项目中的类，提出包的概念
- 使用package声明类或接口所属的包
- 同一个包下，不能命名同名的接口或类

## import

- 导入指定包下的类或接口
- 声明在包和类的声明
- import static: 导入指定类或接口中的静态结构

# 继承

- 减少代码冗余，提高复用性
- 便于功能扩展
- 为多态提供前提

# Object类

如果没有显式的声明一个类的父类，则此类继承于java.lang.Object类

# 重写

在子类中对继承于父类的方法进行重写

- 方法名和形参列表相同
- 子类中重写的方法的权限修饰符不能小于父类中被重写方法的权限修饰符
- 子类不能重写父类中声明为private的方法
- 返回值类型：若被重写方法返回值类型为void，则重写方法只能返回void；若被重写方法返回A类型，则重写方法可以返回A类型或A的子类
- 静态方法无法被重写

# super

指向父类的引用

# 子类对象实例化的过程

从结果看：子类继承父类后，就获得了父类的属性和方法

从过程看：通过子类的构造器创建对象时，会直接或间接的调用父类构造器，直到Object类的构造器，从而在内存中加载了父类的结构，子类可以调用，但不对外暴露

# 多态

可以理解为事物的多种形态

对象的多态性：父类的引用指向子类的对象

```java
Father fa = new Son();
```

多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法

前提：类的继承与方法的重写

只适用于方法，不能用于属性

虚拟方法：在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用子类的方法

向下转型：可以使用强制类型转换调用子类特有的方法

# 单元测试

# 包装类

针对八种基本数据类型定义相应的引用类型

自动装箱与自动拆箱

# static

- 静态变量随着类的加载而加载，可以通过类.静态变量调用
- 静态变量的加载早于对象的创建
- 类只会加载一次，静态变量在内存中只会保存一份，存在于方法区的静态域中

# 单例模式Singleton

在系统中，某个类只存在一个实例对象

减少性能开销

```java
//加载时间长，线程安全
class Bank {
  //私有化类的构造器
  private Bank () {}
  //内部创建类的对象
  private Bank instance = new Bank();
  //提供公共的方法，返回类的对象
  public Bank getInstance () {
    return instance;
  }
}
//延迟对象的创建，线程不安全
class Order {
  private Order(){}
  private Order instance = null;
  public static Order getInstance() {
    if(instance == null) {
      instance = new Order;
    }
    return instance;
  }
}
```

# 代码块

- 用来初始化类、对象
- 如果有修饰，只能用static
- 静态代码块：随着类的加载而执行，只执行一次；若有多个，则按声明顺序执行
- 非静态代码块：随着对象的创建而执行，每创建对象都执行一次（初始化对象属性）

# final

- final修饰的类无法被继承
- final修饰的方法无法被重写
- final修饰的变量无法被修改

# 抽象类和抽象方法

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

Java允许类设计者指定：超类声明一个方法但不实现，该方法的实现由子类提供，这样的方法称为抽象方法，有一个或更多抽象方法的类叫做抽象类

## abstract

- abstract修饰的类无法实例化，即为抽象类
- 抽象类中一定有构造器，方便子类实例化时调用
- abstract修饰的方法：抽象方法，没有方法体
- 包含抽象方法的类，一定是抽象类
- 子类重写了父类中所有的抽象方法后，才能被实例化；若没有全部重写，则该子类也为抽象类，需要用abstract修饰

注意点：

- 不能用于修饰属性、构造器、私有方法、静态方法、final的方法和类

## 模板模式

一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式

抽象类体现的就是一种模板模式的设计

# 接口

# 内部类

# 异常处理

# 多线程