---
title: 栈和队列
date: 2021-04-05 14:27:33
tags: [栈,队列]
categories: 数据结构

---

# 栈

栈（Stack）是只允许在一端进行插入和删除操作的线性表

后进先出

## 顺序存储的实现

使用静态数组实现，并需要记录栈顶指针

```c++
#define MaxSize 10
typedef struct {
  ELemType data[MaxSize]; //静态数组存放栈元素
  int top; //栈顶指针
} SqStack;

void InitStack(SqStack &S) {
  S.top = -1;
}

bool Push(SqStack &S, ElemType x) {
  if(S.top == MaxSize - 1) {
    return false	;
  }
  S.data[++S.top] = x;
  return true;
}

bool Pop(SqStack &S, ElemType &x) {
  if(S.top == -1) return false;
  x = S.data[S.top--];
  return true;
}
```

## 共享栈

顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享

![image-20210405162955566](https://tva1.sinaimg.cn/large/008eGmZEly1gp8y8g21vqj30ix09kq3w.jpg)

```c++
#define MaxSize 100
typedef struct {
  ELemType data[MaxSize]; 
  int top1,top2;
} SqDoubleStack
```

## 链式存储

# 队列

只允许在一端插入，在另一端删除的线性表

先进先出

```c++
#define MaxSize 10
typedef struct {
  ELemType data[MaxSize]; //静态数组存放栈元素
  int front,rear; //队头与队尾指针
  int size;
} SqQueue;

void InitQueue(SqQueue &Q) {
  Q.front = Q.rear = 0;
  Q.size = 0;
}

bool EnQueue(SqQueue &Q, ElemType x) {
  if((Q.rear + 1) % MaxSize == Q.front) {
    return false;
  }
  Q.data[Q.rear] = x;
  Q.rear = (Q.rear + 1) % MaxSize;
  size++;
  return true;
}

bool DeQueue(SqQueue &Q, ElemType &x) {
  if(Q.rear == Q.front) return false;
  x = Q.data[Q.front];
  Q.front = (Q.front + 1) % MaxSize;
  size--;
  return true;
}
```

## 双端队列

指允许两端都可以进行入队和出队操作的队列

# 栈的应用

## 括号匹配

算法思想：

若是左括号，入栈；

若是右括号，出栈一个左括号判断是否与之匹配；

检验到字符串尾，还要检查栈是否为空。

只有栈空，整个字符串才是括号匹配的。

## 表达式求值

![image-20210405161722406](https://tva1.sinaimg.cn/large/008eGmZEly1gp8xvewv91j30hw05agma.jpg)

## 递归

```c++
int F(int n) {
  if(n == 0 || n == 1) {
    return 1;
  }
  return n * F(n-1);
}

int Fib(int n) {
  if(n == 0) return 0;
  if(n == 1) return 1;
  return Fib(n-1) + Fib(n-2);
}
```

# 队列的应用

## 树的层次遍历

