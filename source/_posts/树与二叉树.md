---
title: 树与二叉树
date: 2021-04-07 21:20:21
tags: [树,二叉树]
categories: 数据结构
---

# 树

是n个结点的有限集合，n=0时为空树

递归定义的结构

![image-20210407213241507](https://tva1.sinaimg.cn/large/008eGmZEly1gpbi84mp1yj30yo0eijt9.jpg)

森林：m棵互不相交的树的集合

# 树的性质

# 二叉树

## 基本概念

-  或者为空二叉树，即n=0

-  或者由一个根结点和两个互不相交的被称为根的左子树 和右子树组成。左子树和右子树又分别是一棵二叉树。
  - 每个结点最多有两棵子树。
  - 左右子树有顺序

## 特殊的二叉树

- 满二叉树：高度为h，含有2^h-1个结点
- 完全二叉树：在满二叉树的基础上去掉若干个编号更大的结点
- 二叉排序树：左子树的关键字 < 根结点 < 右子树
- 平衡二叉树：左右子树深度之差不超过1

## 存储结构

### 顺序存储

用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素

```c++
struct TreeNode {
  ElemType value;
  bool isEmpty;
};

TreeNode t[MaxSize];
```

### 链式存储

二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子

```c++
struct ElemType {
  int value;
}
typedef struct BiTNode {
  ElemType data;
  struct BiTNode * lChild, *rChild;
  struct BiTNode *parent;
} BiTNode, * BiTree;
```

## 二叉树的遍历

- 先序遍历：根结点 -> 左子树 -> 右子树
- 中序遍历 ：左子树 -> 根结点 -> 右子树
- 后序遍历：左子树 -> 右子树 -> 根结点
- 层序遍历：若树为空，则什么都不做直接返回。 否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问

```c++
void PreOrder(BiTree T) {
  if(T != NULL) {
    visit(T);
    PreOrder(T-<lChild);
    PreOrder(T-<rChild);
  }
}
```

## 构造二叉树

## 线索二叉树

N个结点的二叉链表，每个结点都有指向左右孩子的结点指针，导致有空余指针

- 指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树
- 对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化
- 前驱线索由左孩子指针充当
- 后继线索由右孩子指针充当

中序线索二叉树的存储：

所有**原本为空的右(孩子)指针**改为**指向该节点在中序序列中的后继**，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱

```c++
typedef struct ThreadNode {
  ElemType data;
  struct ThreadNode * lchild, *rchild;
  int ltag,rtag;//左右线索标志 tag=0表示指针指向孩子，tag=1表示指针是线索
}
```

## 二叉排序树

BST（二叉查找树）：左子树的关键字 < 根结点 < 右子树

## 平衡二叉树

AVL树（Balanced Binary Tree）：树上任一结点的左子树和右子树的高度之差不超过1

## 哈夫曼树

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”

算法的描述如下： 

1. 将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。
2. 构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值 置为左、右子树上根结点的权值之和。 
3. 从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 
4. 重复步骤2）和3），直至F中只剩下一棵树为止。



