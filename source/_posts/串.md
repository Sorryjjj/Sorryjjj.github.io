---
title: 串
date: 2021-04-06 21:38:16
tags: [串,KMP]
categories: 数据结构
---

# 串

即字符串，是由0个或多个字符组成的有限序列

- 字串：串中任意个连续的字符组成的子序列
- 主串：包含子串的串
- 串的长度：串中字符的个数
- 空串：串长度为0

串是一种特殊的线性表

串的数据对象限定为字符集

串的基本操作（增删改查）通常以子串为操作对象

# 字符集编码

任何数据存到计算机中一定是二进制数

字符与二进制的对应规则即为编码

## 字符集

英文字符：ASCII字符集

中英文：Unicode字符集

基于同一个字符集可以有多种编码方案：UTF8，UTF-16

# 存储结构

## 顺序存储

```c++
#define MaxLen 255
typedef struct {
  char ch[MaxLen];
  int length;
} SString;

typedef struct {
  char *ch;
  int length;
} HString;
```

## 链式存储

存储密度低，每个字符1B，每个指针4B

一般：

```c++
typedef struct {
  char ch[4];
  struct StringNode * next;
} StringNode, * String;
```

# 朴素模式匹配算法

**模式匹配**：在主串中找到与模式串相同的子串，并返回所在位置

将主串中与模式串长度相同的子串拿出来，逐个与模式串对比，若有不匹配，则开始匹配下一个子串

最坏时间复杂度O(mn)

# KMP算法

当子串与模式串不匹配时，主串指针i不回溯，模式串指针j=next[j]

O(n+m)

```c++
void prefix_table(char pattern [], int prefix [], int n) {
  prefix[0] = 0;
  int len = 0;
  int i = 1;
  while (i < n) {
    if(pattern[i] == pattern[len]) {
      len++;
      prefix[i] = len;
      i++;
    }
    else {
      if(len > 0) {
        len = prefix[len - 1];
      }
      else {
        prefix[i] = len;
        i++;
      }
    }
  }
}

void move_prefix_table (int prefix [], int n) {
  	int i;
  for(i = n - 1; i > 0; i--) {
    prefix[i] = prefix [i - 1];
  }
  prefix[0] = -1;
}	

void kmp_search(char text[], char pattern []) {
  int n = strlen(pattern);
  int m = strlen(text);
  int * prefix = malloc(sizeof(int) * n);
  prefix_table(pattern,prefix,n);
  int i=0,j=0;
  while(i < m) {
    if(j == n-1 && text[i] == pattern[j]) {
      printf("Found pattern at %d\n", i - j);
    }
    if(text[i] == pattern[j]) {
      i++;
      j++;
    }
    else {
      j = prefix[j];
      if(j == -1) {
        i++;
        j++;
      }
    }
  }
}

int main() {
  char pattern[] = "ABABCABAA";
  char text[] = "ABABABCABAABABABAB";
  kmp_search(text,pattern);
  /*int prefix[9];
  int n = 9;
  prefix_table(pattern,prefix,n);
  move_prefix_table(prefix,n);
  for(int i = 0; i < n; i++) {
    printf("%d",prefix[i]);
  }*/
  return 0;
}
```



# KMP算法优化

优化next数组

